---
import { Image } from 'astro:assets'
import netherrack from '../assets/netherrack.png'
import grassBlock from '../assets/grassblock.png'
import '../styles/monocraft.css'
---

<div id="coordinates">
    <div id="overworld"> 
        <div class="header">
            <Image src={grassBlock} alt="Grass Block" />
            <h1>Overworld</h1>
        </div>
        <div class="coords">
            <div class="coord">
                X: <span class="x" contenteditable="plaintext-only"></span>
            </div>
            <div class="coord">
                Z: <span class="z" contenteditable="plaintext-only"></span>
            </div>
        </div>
    </div>
    <div id="the_nether">
        <div class="header">
            <Image src={netherrack} alt="Netherrack" />
            <h1>Nether</h1>
        </div>
        <div class="coords">
            <div class="coord">
                X: <span class="x" contenteditable="plaintext-only"></span>
            </div>
            <div class="coord">
                Z: <span class="z" contenteditable="plaintext-only"></span>
            </div>
        </div>
    </div>
</div>

<script>
import { effect } from 'nanostores';
import { convertedXCoord, convertedZCoord, Dimension, TELEPORT_REGEX, xCoord, zCoord } from '../portal.ts';

const netherContainer = document.getElementById('the_nether') as HTMLDivElement;
const overworldContainer = document.getElementById('overworld') as HTMLDivElement;

function setupFocus(container: HTMLDivElement) {
    const { xElem, zElem } = getCoordElements(container);
    xElem.parentElement?.addEventListener('click', () => {
        console.log('X coordinate clicked');
        xElem.focus();
    });
    zElem.parentElement?.addEventListener('click', () => {
        console.log('Z coordinate clicked');
        zElem.focus();
    });
}
setupFocus(netherContainer);
setupFocus(overworldContainer);

function getCoordElements(container: HTMLDivElement) {
    const xElem = container.querySelector('.x') as HTMLSpanElement;
    const zElem = container.querySelector('.z') as HTMLSpanElement;
    return { xElem, zElem };
}

function setXCoord(container: HTMLDivElement, value: number | undefined) {
    getCoordElements(container).xElem.textContent = `${value ?? ""}`
}

function setZCoord(container: HTMLDivElement, value: number | undefined) {
    getCoordElements(container).zElem.textContent = `${value ?? ""}`
}

effect([xCoord, convertedXCoord], (xCoord, convertedXCoord) => {
    switch (xCoord?.dimension) {
        case Dimension.Overworld:
            setXCoord(overworldContainer, xCoord.value)
            setXCoord(netherContainer, convertedXCoord)
            break;
        case Dimension.Nether:
            setXCoord(netherContainer, xCoord.value)
            setXCoord(overworldContainer, convertedXCoord)
            break;
        default:
            setXCoord(overworldContainer, undefined)
            setXCoord(netherContainer, undefined)
    }
    return () => {
        setXCoord(overworldContainer, undefined)
        setXCoord(netherContainer, undefined)
    }
})

effect([zCoord, convertedZCoord], (zCoord, convertedZCoord) => {
    switch (zCoord?.dimension) {
        case Dimension.Overworld:
            setZCoord(overworldContainer, zCoord.value)
            setZCoord(netherContainer, convertedZCoord)
            break;
        case Dimension.Nether:
            setZCoord(netherContainer, zCoord.value)
            setZCoord(overworldContainer, convertedZCoord)
            break;
        default:
            setZCoord(overworldContainer, undefined)
            setZCoord(netherContainer, undefined)
    }
    return () => {
        setZCoord(overworldContainer, undefined)
        setZCoord(netherContainer, undefined)
    }
})

function insertTextAtCaret(text: string) {
    const sel = window.getSelection();
    if (!sel?.rangeCount) return;

    const range = sel.getRangeAt(0);
    range.deleteContents(); // remove selected text

    const textNode = document.createTextNode(text);
    range.insertNode(textNode);

    // Move caret after inserted text
    range.setStartAfter(textNode);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
}

document.querySelectorAll('span[contenteditable]').forEach(span => {
    span.addEventListener('beforeinput', (e) => {
        const data = (e as InputEvent).data;
        if (data && !/[-0-9\.]/.test(data)) {
            e.preventDefault();
        }
    })
    span.addEventListener('keydown', (e) => {
        if ((e as KeyboardEvent).key === 'Enter') e.preventDefault();
    });
    span.addEventListener('paste', (e) => {
        const text = (e as ClipboardEvent).clipboardData!.getData("text")
        e.preventDefault();
        if (TELEPORT_REGEX.test(text)) return; // allow pasting full command
        console.log('Pasting text:', text);
        e.stopPropagation();
        const filtered = text
            .replace(/\r?\n/g, '')
            .replace(/[^-0-9\.]/g, '');
        insertTextAtCaret(filtered);
    });
    span.addEventListener('focusout', (e) => {
        const parsed = parseInt(span.textContent)
        if (Number.isNaN(parsed)) return;
        const dimension = span.parentElement!.parentElement!.parentElement!.id as Dimension
        if (span.classList.contains("x")) {
            xCoord.set({ value: parsed, dimension: dimension })
        } else if (span.classList.contains("z")) {
            zCoord.set({ value: parsed, dimension: dimension })
        }
    })
});
</script>

<style>
    .header {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .header img {
        height: 2em;
        width: auto;
    }

    .header h1 {
        font-size: 24px;
    }

    .coords {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .coord {
        font-family: 'Monocraft', 'Courier New', Courier, monospace;
        color: rgb(238, 238, 238);
        background: rgb(0, 0, 0);
        padding: 4px 8px;
        border: 2px solid rgb(160, 160, 160);
        cursor: text;
        min-width: 5ch;
    }

    span[contenteditable]:focus {
        outline: none;
    }

    span[contenteditable] {
        white-space: nowrap;
    }
</style>